---
id="2019-01-03-19-19"
title="springCloud学习4（Spring-Cloud-Stream事件驱动）"
headWord="像微服务这样的分布式架构中，需要确保跨多个服务调用的关键行为（如安全、日志记录、用户跟踪等）能够正常运行，这就需要一个服务网关来统一处理。"
tags=["spring-boot", "spring-cloud","spring-cloud-stream","kafka","事件驱动"]
category="java"
serie="springCloud实战"
---

&emsp;&emsp;想想平常生活中做饭的场景，在用电饭锅做饭的同时，我们可以洗菜、切菜,等待电饭锅发出饭做好的提示我们回去拔下电饭锅电源（或者什么也不知让它处于保温状态），反正这个时候我们知道饭做好了，接下来可以炒菜了。从这里可以看出我们在日常生活中与世界的互动并不是同步的、线性的，不是简单的请求--响应模型。它是事件驱动的，我们不断的发送消息、接受消息、处理消息。 

&emsp;&emsp;同样在软件世界中也不全是请求--响应模型，也会需要进行异步的消息通信。使用消息实现事件通信的概念被称为消息驱动架构（Event Driven Architecture,EDA），也被称为消息驱动架构（Message Driven Architecture,MDA）。使用这类架构可以构建高度解耦的系统，该系统能够对变化做出响应，且不需要与特定的库或者服务紧密耦合。

&emsp;&emsp;在Spring Cloud项目中可以使用**Spirng Cloud Stream**轻而易举的构建基于消息传递的解决方案。

# 1、为什么使用消息传递

&emsp;&emsp;要解答这个问题，让我们从一个例子开始，之前一直使用的两个服务：许可证服务和组织服务。每次对许可证服务进行请求，许可证服务都要通过http请求到组织服务上查询组织信息。显而易见这次额外的http请求会花费较长的时间。如果能够将缓存组织数据的读操作，将会大幅提高许可证服务的响应时间。但是缓存数据有如下3个要求:

- **缓存的数据需要在许可证服务的所有实例之间保存一致**——这意味着不能将数据缓存到服务实例的内存中。
- **在更新或者删除一个组织数据时，许可证服务缓存的数据需要失效**——避免读取到过期数据，需要尽早让过时数据失效并删除。

&emsp;&emsp;要实现上面的要求，现在有两种办法。

1. 使用同步请求--响应模型来实现。组织服务在组织数据变化时调用许可证服务的接口通知组织服务已经变化，或者直接操作许可证服务的缓存。

2. 使用事件驱动。组织服务发出一个异步消息。许可证服务收到该消息后清除对应的缓存。


## 1.1、同步请求-响应方式

&emsp;&emsp;对于组织服务的缓存使用Redis来进行存储。下图展示了传统的同步请求--响应来构建的缓存。
